require "active_record"
require "pg"
require "json"
require "fileutils"

script_root = File.expand_path(File.dirname(__FILE__))

# Saves each record as json into a local `data` directory formatted for firebase
# insertion. A separate node process will then read each file and perform the upload.
#
# For all records except for site we need to translate from the original
# postgres id to an autogenerated firebase one. In order to relink records
# we will need to know both of them locally.
#
# So for every record type except site the name of the file will be the original
# postgres id for the record. As the uploads occur the id's can be rewritten.
#
# We do not need to do this for sites since we are only importing ACES data.
class DataExport

    def self.root
        script_root = File.expand_path(File.dirname(__FILE__))
        return "#{script_root}/data"
    end

    def self.clean
        FileUtils.rm_rf(DataExport.root)
    end

    def self.setup
        DataExport.clean
        Dir.mkdir(DataExport.root)
        Dir.mkdir(DataExport.root + '/sites')
        Dir.mkdir(DataExport.root + '/activities')
        Dir.mkdir(DataExport.root + '/geo')
        Dir.mkdir(DataExport.root + '/geo/activities')
        Dir.mkdir(DataExport.root + '/users')
        Dir.mkdir(DataExport.root + '/ideas')
        Dir.mkdir(DataExport.root + '/observations')
    end

    def self.write_site (site)
        File.open(DataExport.root + "/sites/#{site.name}.json", 'w+') do |file|
            file.write(site.aces_firebase_json)
        end
    end

    def self.write_activity (activity)
        File.open(DataExport.root + "/activities/-ACES_a#{activity.id}.json", 'w+') do |file|
            file.write(activity.activity_firebase_json)
        end
        #each activity should have a single geo instance
        File.open(DataExport.root + "/geo/activities/-ACES_g#{activity.id}.json", 'w+') do |file|
            file.write(activity.activity_location_firebase_json)
        end
    end

    def self.write_observation (observation)
        File.open(DataExport.root + "/observations/-ACES_o#{observation.id}.json", 'w+') do |file|
            file.write(observation.observation_firebase_json)
        end
    end

    def self.write_design_idea (idea)
        File.open(DataExport.root + "/ideas/-ACES_d#{idea.id}.json", 'w+') do |file|
            file.write(idea.design_idea_firebase_json)
        end
    end

    def self.write_user(user)
        File.open(DataExport.root + "/users/-ACES_u#{user.id}.json", 'w+') do |file|
            file.write(user.user_firebase_json)
        end
    end

end

class Site < ActiveRecord::Base
    self.table_name = 'site'
    has_many :contexts

    # currently only care about aces in the migration
    def self.aces
        Site.includes(:contexts).find_by(name: 'aces')
    end

    def activities
        contexts.reject { |c| c.kind != 'Activity' }
    end

    # The old model didn't keep the site's overall location. Since we're only migrating
    # one site we'll hardcode the conversion here. Still reads the other values from the record.
    def aces_firebase_json
        return JSON.pretty_generate(name: name, description: description, location: [39.1965355,-106.8242489])
    end
end

class Context < ActiveRecord::Base
    self.table_name = 'context'

    # Converts `kind == 'Activity'` records into firebase compatible activities
    # Cannot create and /geo/activities entries since there is no location data
    def activity_firebase_json
        raise "#{name} is not an activity" unless kind == 'Activity'

        #Depending on the specific activity, extras may or may not contain anything useful
        begin
          extra_data = JSON.parse(extras)
        rescue JSON::ParserError => e
          extra_data = {}
        end

        icon = extras
        #extra_data['Icon'] || "http://res.cloudinary.com/university-of-colorado/image/upload/v1427400563/2_FreeObservations_mjzgnh.png"

        template = {}
        ['web', 'ios', 'andriod'].each do |key|
            template[key] = extra_data['type'] || 'no data'
        end

        status = "Completed"

        return JSON.pretty_generate(id: "-ACES_a#{id}", name: title, description: description, icon_url: icon, status: status)
    end

    # also write out an instance at ACES, which is not directly given in the old model
    def activity_location_firebase_json
        raise "#{name} is not an activity" unless kind == 'Activity'
        site = 'aces'
        return JSON.pretty_generate(id: "-ACES_g#{id}", activity: "-ACES_a#{id}", site: site, location: [39.1965355,-106.8242489])
    end
end

class Note < ActiveRecord::Base
    self.table_name = 'note'
    has_one :media

    def self.observations
        Note.includes(:media).where(kind: 'FieldNote')
    end

    def self.design_ideas
        Note.where(kind: 'DesignIdea')
    end

    def media?
        return media != nil
    end

    def observation_firebase_json
        raise "#{id} is not an observation" unless kind == "FieldNote"

        cloudinary_root = "http://res.cloudinary.com/university-of-colorado/image/upload/v1400187706/"

        data = {}
        data['text'] = content
        data['image'] = cloudinary_root + media.link if media?

        l = [latitude, longitude]
        return JSON.pretty_generate(id: "-ACES_o#{id}", activity_location: "-ACES_g#{context_id}", observer: "-ACES_u#{account_id}", data: data, l: l, status: status, created_at: (created_at.to_i * 1000), updated_at: (modified_at.to_i * 1000))
    end

    def design_idea_firebase_json
      raise "#{id} is not a design idea" unless kind == "DesignIdea"

      return JSON.pretty_generate(id: "-ACES_d#{id}", content: content, status: status, submitter: "-ACES_u#{account_id}", group: "Deprecated", created_at: (created_at.to_i * 1000), updated_at: (modified_at.to_i * 1000))
    end
end

class Media < ActiveRecord::Base
    self.table_name = 'media'

end

# Read the connection url from the .env file in the project root
File.new(script_root + "/../.env").each_line do |line|
    key, value = line.split('=')
    ActiveRecord::Base.establish_connection(value) if key == 'POSTGRES_URL'
end

class User < ActiveRecord::Base
    self.table_name = 'account'

    def user_firebase_json
        profile = {}
        profile['id'] = "-ACES_u#{id}"
        profile['display_name'] = username
        profile['avatar'] = icon_url
        profile['affiliation'] = 'aces'
        profile['created_at'] = created_at.to_i * 1000
        profile['updated_at'] = modified_at.to_i * 1000
        return JSON.pretty_generate(profile)
    end
end

DataExport.setup

aces = Site.aces
DataExport.write_site(aces)
aces.activities.each { |a| DataExport.write_activity(a) }
Note.observations.each { |o| DataExport.write_observation(o) }
Note.design_ideas.each { |d| DataExport.write_design_idea(d) }
User.all.each { |u| DataExport.write_user(u) }



=begin
# finding linked photos for observations
Note.observations.find_each do |note|
    if note.media? && note.media.link
        puts "#{note.id} | #{note.kind} #{note.content} #{note.media.link}"
    else
        puts "#{note.id} | #{note.kind} #{note.content}"
    end
end
=end
